/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST API Reference
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.7.15
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'http://localhost:3000';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
    "string",
    "boolean",
    "double",
    "integer",
    "long",
    "float",
    "number",
    "any"
];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0 || type === 'UInt64DTO') { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {
                [index: string]: any
            } = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0 || type === 'UInt64DTO') { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) { // is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class AccountDTO {
    /**
     * The account unique address in hexadecimal. 
     */
    'address': string;
    'addressHeight': UInt64DTO;
    /**
     * The public key of an account can be used to verify signatures of the account. Only accounts that have already published a transaction have a public key assigned to the account. Otherwise, the field is null. 
     */
    'publicKey': string;
    'publicKeyHeight': UInt64DTO;
    /**
     * The list of mosaics the account owns. The amount is represented in absolute amount. Thus a balance of 123456789 for a mosaic with divisibility 6 (absolute) means the account owns 123.456789 instead. 
     */
    'mosaics': Array < MosaicDTO > ;
    'importance': UInt64DTO;
    'importanceHeight': UInt64DTO;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "addressHeight",
            "baseName": "addressHeight",
            "type": "UInt64DTO"
        },
        {
            "name": "publicKey",
            "baseName": "publicKey",
            "type": "string"
        },
        {
            "name": "publicKeyHeight",
            "baseName": "publicKeyHeight",
            "type": "UInt64DTO"
        },
        {
            "name": "mosaics",
            "baseName": "mosaics",
            "type": "Array<MosaicDTO>"
        },
        {
            "name": "importance",
            "baseName": "importance",
            "type": "UInt64DTO"
        },
        {
            "name": "importanceHeight",
            "baseName": "importanceHeight",
            "type": "UInt64DTO"
        }
    ];

    static getAttributeTypeMap() {
        return AccountDTO.attributeTypeMap;
    }
}

export class AccountInfoDTO {
    'meta': AccountMetaDTO;
    'account': AccountDTO;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "meta",
            "baseName": "meta",
            "type": "AccountMetaDTO"
        },
        {
            "name": "account",
            "baseName": "account",
            "type": "AccountDTO"
        }
    ];

    static getAttributeTypeMap() {
        return AccountInfoDTO.attributeTypeMap;
    }
}

export class AccountMetaDTO {
    'height': UInt64DTO;
    'hash': string;
    'merkleComponentHash': string;
    'index': number;
    'id': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "height",
            "baseName": "height",
            "type": "UInt64DTO"
        },
        {
            "name": "hash",
            "baseName": "hash",
            "type": "string"
        },
        {
            "name": "merkleComponentHash",
            "baseName": "merkleComponentHash",
            "type": "string"
        },
        {
            "name": "index",
            "baseName": "index",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }
    ];

    static getAttributeTypeMap() {
        return AccountMetaDTO.attributeTypeMap;
    }
}

export class AccountNamesDTO {
    /**
     * The address of the account in base 32.
     */
    'address': string;
    /**
     * The mosaic linked namespace names.
     */
    'names': Array < string > ;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "names",
            "baseName": "names",
            "type": "Array<string>"
        }
    ];

    static getAttributeTypeMap() {
        return AccountNamesDTO.attributeTypeMap;
    }
}

export class AccountPropertiesDTO {
    /**
     * The address of the account in hexadecimal.
     */
    'address': string;
    'properties': Array < AccountPropertyDTO > ;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "properties",
            "baseName": "properties",
            "type": "Array<AccountPropertyDTO>"
        }
    ];

    static getAttributeTypeMap() {
        return AccountPropertiesDTO.attributeTypeMap;
    }
}

export class AccountPropertiesInfoDTO {
    'accountProperties': AccountPropertiesDTO;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
        "name": "accountProperties",
        "baseName": "accountProperties",
        "type": "AccountPropertiesDTO"
    }];

    static getAttributeTypeMap() {
        return AccountPropertiesInfoDTO.attributeTypeMap;
    }
}

export class AccountPropertyDTO {
    'propertyType': AccountPropertyTypeEnum;
    /**
     * The address, transaction type or mosaic id to filter.
     */
    'values': Array < any > ;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "propertyType",
            "baseName": "propertyType",
            "type": "AccountPropertyTypeEnum"
        },
        {
            "name": "values",
            "baseName": "values",
            "type": "Array<any>"
        }
    ];

    static getAttributeTypeMap() {
        return AccountPropertyDTO.attributeTypeMap;
    }
}

/**
 * The account properties type: * 0x01 (1 decimal) - The property type only allows receiving transactions from an address. * 0x02 (2 decimal) - The property type only allows receiving transactions containing a mosaic id. * 0x04 (4 decimal) - The property type only allows sending transactions with a given transaction type. * 0x05 (5 decimal) - Property type sentinel. * 0x81 (129 decimal) - The property type blocks receiving transactions from an address. * 0x82 (130 decimal) - The property type blocks receiving transactions containing a mosaic id. * 0x84 (132 decimal) -  The property type blocks sending transactions with a given transaction type. 
 */
export class AccountPropertyTypeEnum {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [];

    static getAttributeTypeMap() {
        return AccountPropertyTypeEnum.attributeTypeMap;
    }
}

export class AccountsIds {
    /**
     * The array of public keys.
     */
    'publicKeys' ? : Array < string > ;
    /**
     * The array of addresses.
     */
    'addresses' ? : Array < string > ;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "publicKeys",
            "baseName": "publicKeys",
            "type": "Array<string>"
        },
        {
            "name": "addresses",
            "baseName": "addresses",
            "type": "Array<string>"
        }
    ];

    static getAttributeTypeMap() {
        return AccountsIds.attributeTypeMap;
    }
}

export class AliasDTO {
    'type': AliasTypeEnum;
    'mosaicId' ? : UInt64DTO;
    /**
     * The aliased address in hexadecimal.
     */
    'address' ? : string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "type",
            "baseName": "type",
            "type": "AliasTypeEnum"
        },
        {
            "name": "mosaicId",
            "baseName": "mosaicId",
            "type": "UInt64DTO"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        }
    ];

    static getAttributeTypeMap() {
        return AliasDTO.attributeTypeMap;
    }
}

/**
 * The alias type: * 0 -  No alias. * 1 -  Mosaic id alias. * 2 -  Addres alias. 
 */
export class AliasTypeEnum {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [];

    static getAttributeTypeMap() {
        return AliasTypeEnum.attributeTypeMap;
    }
}

export class AnnounceTransactionInfoDTO {
    'message': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
        "name": "message",
        "baseName": "message",
        "type": "string"
    }];

    static getAttributeTypeMap() {
        return AnnounceTransactionInfoDTO.attributeTypeMap;
    }
}

export class BlockDTO {
    /**
     * The signature of the block. The signature was generated by the signer and can be used to validate tha the entity data was not modified by a node. 
     */
    'signature': string;
    /**
     * The public key of the block harvester formatted as hexadecimal.
     */
    'signer': string;
    'version': NetworkTypeEnum;
    /**
     * The block type: * 0x8043 (32835 decimal) - Nemesis block. * 0x8143 (33091 decimal) - Regular block. 
     */
    'type': number;
    'height': UInt64DTO;
    'timestamp': UInt64DTO;
    'difficulty': UInt64DTO;
    /**
     * The fee multiplier applied to transactions contained in block.
     */
    'feeMultiplier': number;
    /**
     * The hash of the previous block.
     */
    'previousBlockHash': string;
    /**
     * The transactions included in a block are hashed forming a merkle tree. The root of the tree summarizes them. 
     */
    'blockTransactionsHash': string;
    /**
     * The collection of receipts  are hashed into a merkle tree and linked to a block. The block header stores the root hash. 
     */
    'blockReceiptsHash': string;
    /**
     * For each block, the state of the blockchain is stored in RocksDB, forming a patricia tree. The root of the tree summarizes the state of the blockchain for the given block. 
     */
    'stateHash': string;
    /**
     * The public key of the optional beneficiary designated by harvester.
     */
    'beneficiary': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "signature",
            "baseName": "signature",
            "type": "string"
        },
        {
            "name": "signer",
            "baseName": "signer",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "NetworkTypeEnum"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "number"
        },
        {
            "name": "height",
            "baseName": "height",
            "type": "UInt64DTO"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "UInt64DTO"
        },
        {
            "name": "difficulty",
            "baseName": "difficulty",
            "type": "UInt64DTO"
        },
        {
            "name": "feeMultiplier",
            "baseName": "feeMultiplier",
            "type": "number"
        },
        {
            "name": "previousBlockHash",
            "baseName": "previousBlockHash",
            "type": "string"
        },
        {
            "name": "blockTransactionsHash",
            "baseName": "blockTransactionsHash",
            "type": "string"
        },
        {
            "name": "blockReceiptsHash",
            "baseName": "blockReceiptsHash",
            "type": "string"
        },
        {
            "name": "stateHash",
            "baseName": "stateHash",
            "type": "string"
        },
        {
            "name": "beneficiary",
            "baseName": "beneficiary",
            "type": "string"
        }
    ];

    static getAttributeTypeMap() {
        return BlockDTO.attributeTypeMap;
    }
}

export class BlockInfoDTO {
    'meta': BlockMetaDTO;
    'block': BlockDTO;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "meta",
            "baseName": "meta",
            "type": "BlockMetaDTO"
        },
        {
            "name": "block",
            "baseName": "block",
            "type": "BlockDTO"
        }
    ];

    static getAttributeTypeMap() {
        return BlockInfoDTO.attributeTypeMap;
    }
}

export class BlockMetaDTO {
    'hash': string;
    'generationHash': string;
    'subCacheMerkleRoots': Array < string > ;
    'totalFee': UInt64DTO;
    'numTransactions': number;
    'numStatements' ? : number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "hash",
            "baseName": "hash",
            "type": "string"
        },
        {
            "name": "generationHash",
            "baseName": "generationHash",
            "type": "string"
        },
        {
            "name": "subCacheMerkleRoots",
            "baseName": "subCacheMerkleRoots",
            "type": "Array<string>"
        },
        {
            "name": "totalFee",
            "baseName": "totalFee",
            "type": "UInt64DTO"
        },
        {
            "name": "numTransactions",
            "baseName": "numTransactions",
            "type": "number"
        },
        {
            "name": "numStatements",
            "baseName": "numStatements",
            "type": "number"
        }
    ];

    static getAttributeTypeMap() {
        return BlockMetaDTO.attributeTypeMap;
    }
}

export class BlockchainScoreDTO {
    'scoreHigh': UInt64DTO;
    'scoreLow': UInt64DTO;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "scoreHigh",
            "baseName": "scoreHigh",
            "type": "UInt64DTO"
        },
        {
            "name": "scoreLow",
            "baseName": "scoreLow",
            "type": "UInt64DTO"
        }
    ];

    static getAttributeTypeMap() {
        return BlockchainScoreDTO.attributeTypeMap;
    }
}

export class CommunicationTimestamps {
    'sendTimestamp' ? : UInt64DTO;
    'receiveTimestamp' ? : UInt64DTO;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "sendTimestamp",
            "baseName": "sendTimestamp",
            "type": "UInt64DTO"
        },
        {
            "name": "receiveTimestamp",
            "baseName": "receiveTimestamp",
            "type": "UInt64DTO"
        }
    ];

    static getAttributeTypeMap() {
        return CommunicationTimestamps.attributeTypeMap;
    }
}

export class Cosignature {
    /**
     * The hash of parent aggregate transaction that has been signed by a cosignatory of the transaction.
     */
    'parentHash' ? : string;
    /**
     * The signatures generated by signing the parent aggregate transaction hash.
     */
    'signature' ? : string;
    /**
     * The signer of the transaction.
     */
    'signer' ? : string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "parentHash",
            "baseName": "parentHash",
            "type": "string"
        },
        {
            "name": "signature",
            "baseName": "signature",
            "type": "string"
        },
        {
            "name": "signer",
            "baseName": "signer",
            "type": "string"
        }
    ];

    static getAttributeTypeMap() {
        return Cosignature.attributeTypeMap;
    }
}

export class HeightInfoDTO {
    'height': UInt64DTO;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
        "name": "height",
        "baseName": "height",
        "type": "UInt64DTO"
    }];

    static getAttributeTypeMap() {
        return HeightInfoDTO.attributeTypeMap;
    }
}

export class MerklePathItem {
    'position' ? : number;
    'hash' ? : string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "position",
            "baseName": "position",
            "type": "number"
        },
        {
            "name": "hash",
            "baseName": "hash",
            "type": "string"
        }
    ];

    static getAttributeTypeMap() {
        return MerklePathItem.attributeTypeMap;
    }
}

export class MerkleProofInfo {
    /**
     * The complementary data needed to calculate the merkle root.
     */
    'merklePath' ? : Array < MerklePathItem > ;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
        "name": "merklePath",
        "baseName": "merklePath",
        "type": "Array<MerklePathItem>"
    }];

    static getAttributeTypeMap() {
        return MerkleProofInfo.attributeTypeMap;
    }
}

export class MerkleProofInfoDTO {
    'payload': MerkleProofInfo;
    'type': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "payload",
            "baseName": "payload",
            "type": "MerkleProofInfo"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }
    ];

    static getAttributeTypeMap() {
        return MerkleProofInfoDTO.attributeTypeMap;
    }
}

export class MosaicDTO {
    'id': UInt64DTO;
    'amount': UInt64DTO;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "id",
            "baseName": "id",
            "type": "UInt64DTO"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "UInt64DTO"
        }
    ];

    static getAttributeTypeMap() {
        return MosaicDTO.attributeTypeMap;
    }
}

export class MosaicDefinitionDTO {
    'mosaicId': UInt64DTO;
    'supply': UInt64DTO;
    'height': UInt64DTO;
    /**
     * The public key of the mosaic owner.
     */
    'owner': string;
    /**
     * The number of definitions for the same mosaic.
     */
    'revision': number;
    'properties': Array < MosaicPropertyDTO > ;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "mosaicId",
            "baseName": "mosaicId",
            "type": "UInt64DTO"
        },
        {
            "name": "supply",
            "baseName": "supply",
            "type": "UInt64DTO"
        },
        {
            "name": "height",
            "baseName": "height",
            "type": "UInt64DTO"
        },
        {
            "name": "owner",
            "baseName": "owner",
            "type": "string"
        },
        {
            "name": "revision",
            "baseName": "revision",
            "type": "number"
        },
        {
            "name": "properties",
            "baseName": "properties",
            "type": "Array<MosaicPropertyDTO>"
        }
    ];

    static getAttributeTypeMap() {
        return MosaicDefinitionDTO.attributeTypeMap;
    }
}

export class MosaicIds {
    /**
     * The array of mosaic identifiers.
     */
    'mosaicIds' ? : Array < string > ;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
        "name": "mosaicIds",
        "baseName": "mosaicIds",
        "type": "Array<string>"
    }];

    static getAttributeTypeMap() {
        return MosaicIds.attributeTypeMap;
    }
}

export class MosaicInfoDTO {
    'meta': MosaicMetaDTO;
    'mosaic': MosaicDefinitionDTO;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "meta",
            "baseName": "meta",
            "type": "MosaicMetaDTO"
        },
        {
            "name": "mosaic",
            "baseName": "mosaic",
            "type": "MosaicDefinitionDTO"
        }
    ];

    static getAttributeTypeMap() {
        return MosaicInfoDTO.attributeTypeMap;
    }
}

export class MosaicMetaDTO {
    'id': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
        "name": "id",
        "baseName": "id",
        "type": "string"
    }];

    static getAttributeTypeMap() {
        return MosaicMetaDTO.attributeTypeMap;
    }
}

export class MosaicNamesDTO {
    'mosaicId': UInt64DTO;
    /**
     * The mosaic linked namespace names.
     */
    'names': Array < string > ;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "mosaicId",
            "baseName": "mosaicId",
            "type": "UInt64DTO"
        },
        {
            "name": "names",
            "baseName": "names",
            "type": "Array<string>"
        }
    ];

    static getAttributeTypeMap() {
        return MosaicNamesDTO.attributeTypeMap;
    }
}

export class MosaicPropertyDTO {
    'id' ? : MosaicPropertyIdEnum;
    'value' ? : UInt64DTO;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "id",
            "baseName": "id",
            "type": "MosaicPropertyIdEnum"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "UInt64DTO"
        }
    ];

    static getAttributeTypeMap() {
        return MosaicPropertyDTO.attributeTypeMap;
    }
}

/**
 * The mosaic propery id means: * 0 - MosaicFlags * 1 - Divisibility * 2 - Duration 
 */
export class MosaicPropertyIdEnum {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [];

    static getAttributeTypeMap() {
        return MosaicPropertyIdEnum.attributeTypeMap;
    }
}

export class MultisigAccountGraphInfoDTO {
    /**
     * The level of the multisig account.
     */
    'level': number;
    /**
     * The array of multisig accounts for this level.
     */
    'multisigEntries': Array < MultisigAccountInfoDTO > ;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "level",
            "baseName": "level",
            "type": "number"
        },
        {
            "name": "multisigEntries",
            "baseName": "multisigEntries",
            "type": "Array<MultisigAccountInfoDTO>"
        }
    ];

    static getAttributeTypeMap() {
        return MultisigAccountGraphInfoDTO.attributeTypeMap;
    }
}

export class MultisigAccountInfoDTO {
    'multisig': MultisigDTO;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
        "name": "multisig",
        "baseName": "multisig",
        "type": "MultisigDTO"
    }];

    static getAttributeTypeMap() {
        return MultisigAccountInfoDTO.attributeTypeMap;
    }
}

export class MultisigDTO {
    /**
     * The account public key.
     */
    'account': string;
    /**
     * The account address in hexadecimal.
     */
    'accountAddress' ? : string;
    /**
     * The number of signatures needed to approve a transaction.
     */
    'minApproval': number;
    /**
     * The number of signatures needed to remove a cosignatory.
     */
    'minRemoval': number;
    /**
     * The array of public keys of the cosignatory accounts.
     */
    'cosignatories': Array < string > ;
    /**
     * The array of multisig accounts where the account is cosignatory.
     */
    'multisigAccounts': Array < string > ;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "account",
            "baseName": "account",
            "type": "string"
        },
        {
            "name": "accountAddress",
            "baseName": "accountAddress",
            "type": "string"
        },
        {
            "name": "minApproval",
            "baseName": "minApproval",
            "type": "number"
        },
        {
            "name": "minRemoval",
            "baseName": "minRemoval",
            "type": "number"
        },
        {
            "name": "cosignatories",
            "baseName": "cosignatories",
            "type": "Array<string>"
        },
        {
            "name": "multisigAccounts",
            "baseName": "multisigAccounts",
            "type": "Array<string>"
        }
    ];

    static getAttributeTypeMap() {
        return MultisigDTO.attributeTypeMap;
    }
}

/**
 * The type of the modification: * 0 - Add cosignatory. * 1 - Remove cosignatory. 
 */
export class MultisigModificationTypeEnum {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [];

    static getAttributeTypeMap() {
        return MultisigModificationTypeEnum.attributeTypeMap;
    }
}

export class NamespaceDTO {
    /**
     * The public key of the owner of the namespace.
     */
    'owner': string;
    /**
     * The address of the owner of the namespace in hexadecimal.
     */
    'ownerAddress': string;
    'startHeight': UInt64DTO;
    'endHeight': UInt64DTO;
    /**
     * The level of the namespace.
     */
    'depth': number;
    'level0': UInt64DTO;
    'level1' ? : UInt64DTO;
    'level2' ? : UInt64DTO;
    'type': NamespaceTypeEnum;
    'alias': AliasDTO;
    'parentId': UInt64DTO;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "owner",
            "baseName": "owner",
            "type": "string"
        },
        {
            "name": "ownerAddress",
            "baseName": "ownerAddress",
            "type": "string"
        },
        {
            "name": "startHeight",
            "baseName": "startHeight",
            "type": "UInt64DTO"
        },
        {
            "name": "endHeight",
            "baseName": "endHeight",
            "type": "UInt64DTO"
        },
        {
            "name": "depth",
            "baseName": "depth",
            "type": "number"
        },
        {
            "name": "level0",
            "baseName": "level0",
            "type": "UInt64DTO"
        },
        {
            "name": "level1",
            "baseName": "level1",
            "type": "UInt64DTO"
        },
        {
            "name": "level2",
            "baseName": "level2",
            "type": "UInt64DTO"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "NamespaceTypeEnum"
        },
        {
            "name": "alias",
            "baseName": "alias",
            "type": "AliasDTO"
        },
        {
            "name": "parentId",
            "baseName": "parentId",
            "type": "UInt64DTO"
        }
    ];

    static getAttributeTypeMap() {
        return NamespaceDTO.attributeTypeMap;
    }
}

export class NamespaceIds {
    /**
     * The array of namespace identifiers.
     */
    'namespaceIds' ? : Array < string > ;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
        "name": "namespaceIds",
        "baseName": "namespaceIds",
        "type": "Array<string>"
    }];

    static getAttributeTypeMap() {
        return NamespaceIds.attributeTypeMap;
    }
}

export class NamespaceInfoDTO {
    'meta': NamespaceMetaDTO;
    'namespace': NamespaceDTO;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "meta",
            "baseName": "meta",
            "type": "NamespaceMetaDTO"
        },
        {
            "name": "namespace",
            "baseName": "namespace",
            "type": "NamespaceDTO"
        }
    ];

    static getAttributeTypeMap() {
        return NamespaceInfoDTO.attributeTypeMap;
    }
}

export class NamespaceMetaDTO {
    'id': string;
    'active': boolean;
    'index': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "index",
            "baseName": "index",
            "type": "number"
        }
    ];

    static getAttributeTypeMap() {
        return NamespaceMetaDTO.attributeTypeMap;
    }
}

export class NamespaceNameDTO {
    'parentId' ? : UInt64DTO;
    'namespaceId': UInt64DTO;
    /**
     * The name of the namespace.
     */
    'name': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "parentId",
            "baseName": "parentId",
            "type": "UInt64DTO"
        },
        {
            "name": "namespaceId",
            "baseName": "namespaceId",
            "type": "UInt64DTO"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }
    ];

    static getAttributeTypeMap() {
        return NamespaceNameDTO.attributeTypeMap;
    }
}

/**
 * The namespace type: * 0 -  Root namespace. * 1 -  Subnamespace. 
 */
export class NamespaceTypeEnum {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [];

    static getAttributeTypeMap() {
        return NamespaceTypeEnum.attributeTypeMap;
    }
}

export class NetworkTypeDTO {
    /**
     * The name of the network.
     */
    'name': string;
    /**
     * A short text describing the network.
     */
    'description': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }
    ];

    static getAttributeTypeMap() {
        return NetworkTypeDTO.attributeTypeMap;
    }
}

/**
 * The entity version. The higher byte represents the network identifier: * 0x68 (MAIN_NET) - Public main network. * 0x98 (TEST_NET) - Public test network. * 0x60 (MIJIN) - Private network. * 0x90 (MIJIN_TEST) - Private test network. 
 */
export class NetworkTypeEnum {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [];

    static getAttributeTypeMap() {
        return NetworkTypeEnum.attributeTypeMap;
    }
}

export class NodeInfoDTO {
    /**
     * The public key used to identify the node.
     */
    'publicKey': string;
    /**
     * The port used for the communication.
     */
    'port': number;
    'networkIdentifier': number;
    /**
     * The version of the application.
     */
    'version': number;
    'roles': RolesTypeEnum;
    /**
     * The IP address of the endpoint.
     */
    'host': string;
    /**
     * The name of the node.
     */
    'friendlyName': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "publicKey",
            "baseName": "publicKey",
            "type": "string"
        },
        {
            "name": "port",
            "baseName": "port",
            "type": "number"
        },
        {
            "name": "networkIdentifier",
            "baseName": "networkIdentifier",
            "type": "number"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "roles",
            "baseName": "roles",
            "type": "RolesTypeEnum"
        },
        {
            "name": "host",
            "baseName": "host",
            "type": "string"
        },
        {
            "name": "friendlyName",
            "baseName": "friendlyName",
            "type": "string"
        }
    ];

    static getAttributeTypeMap() {
        return NodeInfoDTO.attributeTypeMap;
    }
}

export class NodeTimeDTO {
    'communicationTimestamps': CommunicationTimestamps;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
        "name": "communicationTimestamps",
        "baseName": "communicationTimestamps",
        "type": "CommunicationTimestamps"
    }];

    static getAttributeTypeMap() {
        return NodeTimeDTO.attributeTypeMap;
    }
}

/**
 * The type of the receipt: * 0x134D (4941 decimal) - Mosaic_Rental_Fee. * 0x124E (4686 decimal) - Namespace_Rental_Fee. * 0x2143 (8515 decimal) - Harvest_Fee. * 0x2248 (8776 decimal) - LockHash_Completed. * 0x2348 (9032 decimal) - LockHash_Expired. * 0x2252 (8786 decimal) - LockSecret_Completed. * 0x2352 (9042 decimal) - LockSecret_Expired. * 0x3148 (12616 decimal) - LockHash_Created. * 0x3152 (12626 decimal) - LockSecret_Created. * 0x414D (16717 decimal) - Mosaic_Expired. * 0x414E (16718 decimal) - Namespace_Expired. * 0x5143 (20803 decimal) - Inflation. * 0xE134 (57652 decimal) - Transaction_Group. * 0xF143 (61763 decimal) - Address_Alias_Resolution. * 0xF243 (62019 decimal) - Mosaic_Alias_Resolution. 
 */
export class ReceiptTypeEnum {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [];

    static getAttributeTypeMap() {
        return ReceiptTypeEnum.attributeTypeMap;
    }
}

export class ResolutionEntryDTO {
    'source': SourceDTO;
    'resolved': UInt64DTO;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "source",
            "baseName": "source",
            "type": "SourceDTO"
        },
        {
            "name": "resolved",
            "baseName": "resolved",
            "type": "UInt64DTO"
        }
    ];

    static getAttributeTypeMap() {
        return ResolutionEntryDTO.attributeTypeMap;
    }
}

/**
 * A resolution statement keeps the relation between a namespace alias used in a transaction and the real address or mosaicId.
 */
export class ResolutionStatementDTO {
    'height': UInt64DTO;
    'unresolved': UInt64DTO;
    /**
     * The array of resolution entries linked to the unresolved namespaceId. It is an array instead of a single UInt64 field since within one block the resolution might change for different sources due to alias related transactions.
     */
    'resolutionEntries': Array < ResolutionEntryDTO > ;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "height",
            "baseName": "height",
            "type": "UInt64DTO"
        },
        {
            "name": "unresolved",
            "baseName": "unresolved",
            "type": "UInt64DTO"
        },
        {
            "name": "resolutionEntries",
            "baseName": "resolutionEntries",
            "type": "Array<ResolutionEntryDTO>"
        }
    ];

    static getAttributeTypeMap() {
        return ResolutionStatementDTO.attributeTypeMap;
    }
}

/**
 * The role of the node: * 1 - A peer node. * 2 - An api node. 
 */
export class RolesTypeEnum {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [];

    static getAttributeTypeMap() {
        return RolesTypeEnum.attributeTypeMap;
    }
}

export class ServerDTO {
    'serverInfo': ServerInfoDTO;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
        "name": "serverInfo",
        "baseName": "serverInfo",
        "type": "ServerInfoDTO"
    }];

    static getAttributeTypeMap() {
        return ServerDTO.attributeTypeMap;
    }
}

export class ServerInfoDTO {
    /**
     * The catapult-rest component version.
     */
    'restVersion': string;
    /**
     * The catapult-sdk component version.
     */
    'sdkVersion': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "restVersion",
            "baseName": "restVersion",
            "type": "string"
        },
        {
            "name": "sdkVersion",
            "baseName": "sdkVersion",
            "type": "string"
        }
    ];

    static getAttributeTypeMap() {
        return ServerInfoDTO.attributeTypeMap;
    }
}

/**
 * The transaction that triggered the receipt.
 */
export class SourceDTO {
    /**
     * The transaction index within the block.
     */
    'primaryId': number;
    /**
     * The transaction index inside within the aggregate transaction. If the transaction is not an inner transaction, then the secondary id is set to 0.
     */
    'secondaryId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "primaryId",
            "baseName": "primaryId",
            "type": "number"
        },
        {
            "name": "secondaryId",
            "baseName": "secondaryId",
            "type": "number"
        }
    ];

    static getAttributeTypeMap() {
        return SourceDTO.attributeTypeMap;
    }
}

/**
 * The collection of transaction statements and resolutions triggered for the block requested.
 */
export class StatementsDTO {
    /**
     * The array of transaction statements for the block requested.
     */
    'transactionStatements': Array < TransactionStatementDTO > ;
    /**
     * The array of address resolutions for the block requested.
     */
    'addressResolutionStatements': Array < ResolutionStatementDTO > ;
    /**
     * The array of mosaic resolutions for the block requested.
     */
    'mosaicResolutionStatements': Array < ResolutionStatementDTO > ;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "transactionStatements",
            "baseName": "transactionStatements",
            "type": "Array<TransactionStatementDTO>"
        },
        {
            "name": "addressResolutionStatements",
            "baseName": "addressResolutionStatements",
            "type": "Array<ResolutionStatementDTO>"
        },
        {
            "name": "mosaicResolutionStatements",
            "baseName": "mosaicResolutionStatements",
            "type": "Array<ResolutionStatementDTO>"
        }
    ];

    static getAttributeTypeMap() {
        return StatementsDTO.attributeTypeMap;
    }
}

export class StorageInfoDTO {
    /**
     * The number of blocks stored.
     */
    'numBlocks': number;
    /**
     * The number of transactions stored.
     */
    'numTransactions': number;
    /**
     * The number of accounts created.
     */
    'numAccounts': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "numBlocks",
            "baseName": "numBlocks",
            "type": "number"
        },
        {
            "name": "numTransactions",
            "baseName": "numTransactions",
            "type": "number"
        },
        {
            "name": "numAccounts",
            "baseName": "numAccounts",
            "type": "number"
        }
    ];

    static getAttributeTypeMap() {
        return StorageInfoDTO.attributeTypeMap;
    }
}

export class TransactionHashes {
    /**
     * The array of transaction hashes.
     */
    'hashes' ? : Array < string > ;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
        "name": "hashes",
        "baseName": "hashes",
        "type": "Array<string>"
    }];

    static getAttributeTypeMap() {
        return TransactionHashes.attributeTypeMap;
    }
}

export class TransactionIds {
    /**
     * The array of transaction ids.
     */
    'transactionIds' ? : Array < string > ;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
        "name": "transactionIds",
        "baseName": "transactionIds",
        "type": "Array<string>"
    }];

    static getAttributeTypeMap() {
        return TransactionIds.attributeTypeMap;
    }
}

export class TransactionInfoDTO {
    'meta': TransactionMetaDTO;
    'transaction': any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "meta",
            "baseName": "meta",
            "type": "TransactionMetaDTO"
        },
        {
            "name": "transaction",
            "baseName": "transaction",
            "type": "any"
        }
    ];

    static getAttributeTypeMap() {
        return TransactionInfoDTO.attributeTypeMap;
    }
}

export class TransactionMetaDTO {
    'height': UInt64DTO;
    'hash': string;
    'merkleComponentHash': string;
    'index': number;
    'id': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "height",
            "baseName": "height",
            "type": "UInt64DTO"
        },
        {
            "name": "hash",
            "baseName": "hash",
            "type": "string"
        },
        {
            "name": "merkleComponentHash",
            "baseName": "merkleComponentHash",
            "type": "string"
        },
        {
            "name": "index",
            "baseName": "index",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }
    ];

    static getAttributeTypeMap() {
        return TransactionMetaDTO.attributeTypeMap;
    }
}

export class TransactionPayload {
    /**
     * The transaction payload.
     */
    'payload' ? : string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
        "name": "payload",
        "baseName": "payload",
        "type": "string"
    }];

    static getAttributeTypeMap() {
        return TransactionPayload.attributeTypeMap;
    }
}

/**
 * The collection of receipts related to a transaction.
 */
export class TransactionStatementDTO {
    'height': UInt64DTO;
    'source': SourceDTO;
    /**
     * The array of receipts.
     */
    'receipts': Array < any > ;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "height",
            "baseName": "height",
            "type": "UInt64DTO"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "SourceDTO"
        },
        {
            "name": "receipts",
            "baseName": "receipts",
            "type": "Array<any>"
        }
    ];

    static getAttributeTypeMap() {
        return TransactionStatementDTO.attributeTypeMap;
    }
}

export class TransactionStatusDTO {
    'group' ? : string;
    'status': string;
    'hash' ? : string;
    'deadline' ? : UInt64DTO;
    'height' ? : UInt64DTO;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array < {
        name: string,
        baseName: string,
        type: string
    } > = [{
            "name": "group",
            "baseName": "group",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "hash",
            "baseName": "hash",
            "type": "string"
        },
        {
            "name": "deadline",
            "baseName": "deadline",
            "type": "UInt64DTO"
        },
        {
            "name": "height",
            "baseName": "height",
            "type": "UInt64DTO"
        }
    ];

    static getAttributeTypeMap() {
        return TransactionStatusDTO.attributeTypeMap;
    }
}

export class UInt64DTO extends Array < number > {

    static discriminator: string | undefined = undefined;

}


let enumsMap: {
    [index: string]: any
} = {
    "AccountPropertyTypeEnum": AccountPropertyTypeEnum,
    "AliasTypeEnum": AliasTypeEnum,
    "MosaicPropertyIdEnum": MosaicPropertyIdEnum,
    "MultisigModificationTypeEnum": MultisigModificationTypeEnum,
    "NamespaceTypeEnum": NamespaceTypeEnum,
    "NetworkTypeEnum": NetworkTypeEnum,
    "ReceiptTypeEnum": ReceiptTypeEnum,
    "RolesTypeEnum": RolesTypeEnum,
}

let typeMap: {
    [index: string]: any
} = {
    "AccountDTO": AccountDTO,
    "AccountInfoDTO": AccountInfoDTO,
    "AccountMetaDTO": AccountMetaDTO,
    "AccountNamesDTO": AccountNamesDTO,
    "AccountPropertiesDTO": AccountPropertiesDTO,
    "AccountPropertiesInfoDTO": AccountPropertiesInfoDTO,
    "AccountPropertyDTO": AccountPropertyDTO,
    "AccountsIds": AccountsIds,
    "AliasDTO": AliasDTO,
    "AnnounceTransactionInfoDTO": AnnounceTransactionInfoDTO,
    "BlockDTO": BlockDTO,
    "BlockInfoDTO": BlockInfoDTO,
    "BlockMetaDTO": BlockMetaDTO,
    "BlockchainScoreDTO": BlockchainScoreDTO,
    "CommunicationTimestamps": CommunicationTimestamps,
    "Cosignature": Cosignature,
    "HeightInfoDTO": HeightInfoDTO,
    "MerklePathItem": MerklePathItem,
    "MerkleProofInfo": MerkleProofInfo,
    "MerkleProofInfoDTO": MerkleProofInfoDTO,
    "MosaicDTO": MosaicDTO,
    "MosaicDefinitionDTO": MosaicDefinitionDTO,
    "MosaicIds": MosaicIds,
    "MosaicInfoDTO": MosaicInfoDTO,
    "MosaicMetaDTO": MosaicMetaDTO,
    "MosaicNamesDTO": MosaicNamesDTO,
    "MosaicPropertyDTO": MosaicPropertyDTO,
    "MultisigAccountGraphInfoDTO": MultisigAccountGraphInfoDTO,
    "MultisigAccountInfoDTO": MultisigAccountInfoDTO,
    "MultisigDTO": MultisigDTO,
    "NamespaceDTO": NamespaceDTO,
    "NamespaceIds": NamespaceIds,
    "NamespaceInfoDTO": NamespaceInfoDTO,
    "NamespaceMetaDTO": NamespaceMetaDTO,
    "NamespaceNameDTO": NamespaceNameDTO,
    "NetworkTypeDTO": NetworkTypeDTO,
    "NodeInfoDTO": NodeInfoDTO,
    "NodeTimeDTO": NodeTimeDTO,
    "ResolutionEntryDTO": ResolutionEntryDTO,
    "ResolutionStatementDTO": ResolutionStatementDTO,
    "ServerDTO": ServerDTO,
    "ServerInfoDTO": ServerInfoDTO,
    "SourceDTO": SourceDTO,
    "StatementsDTO": StatementsDTO,
    "StorageInfoDTO": StorageInfoDTO,
    "TransactionHashes": TransactionHashes,
    "TransactionIds": TransactionIds,
    "TransactionInfoDTO": TransactionInfoDTO,
    "TransactionMetaDTO": TransactionMetaDTO,
    "TransactionPayload": TransactionPayload,
    "TransactionStatementDTO": TransactionStatementDTO,
    "TransactionStatusDTO": TransactionStatusDTO,
    "UInt64DTO": UInt64DTO,
}

export interface Authentication {
    /**
     * Apply authentication settings to header and query params.
     */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username,
            password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {}

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            ( < any > requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AccountRoutesApiApiKeys {}

export class AccountRoutesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications = {
        'default': < Authentication > new VoidAuth(),
    }

    constructor(basePath ? : string);
    constructor(basePathOrUsername: string, password ? : string, basePath ? : string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: AccountRoutesApiApiKeys, value: string) {
        (this.authentications as any)[AccountRoutesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Returns the account information.
     * @summary Get account information
     * @param accountId The public key or address of the account.
     * @param {*} [options] Override http request options.
     */
    public getAccountInfo(accountId: string, options: any = {}): Promise < {
        response: http.ClientResponse;body: AccountInfoDTO;
    } > {
        const localVarPath = this.basePath + '/account/{accountId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountInfo.');
        }

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: AccountInfoDTO;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountInfoDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
    /**
     * Returns the multisig account information.
     * @summary Get multisig account information
     * @param accountId The public key or address of the account.
     * @param {*} [options] Override http request options.
     */
    public getAccountMultisig(accountId: string, options: any = {}): Promise < {
        response: http.ClientResponse;body: MultisigAccountInfoDTO;
    } > {
        const localVarPath = this.basePath + '/account/{accountId}/multisig'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountMultisig.');
        }

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: MultisigAccountInfoDTO;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MultisigAccountInfoDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
    /**
     * Returns the multisig account graph.
     * @summary Get multisig account graph information
     * @param accountId The public key or address of the account.
     * @param {*} [options] Override http request options.
     */
    public getAccountMultisigGraph(accountId: string, options: any = {}): Promise < {
        response: http.ClientResponse;body: Array < MultisigAccountGraphInfoDTO > ;
    } > {
        const localVarPath = this.basePath + '/account/{accountId}/multisig/graph'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountMultisigGraph.');
        }

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: Array < MultisigAccountGraphInfoDTO > ;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<MultisigAccountGraphInfoDTO>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
    /**
     * Returns the configurable properties for a given account.
     * @summary Get account configurable properties information
     * @param accountId The public key or address of the account.
     * @param {*} [options] Override http request options.
     */
    public getAccountProperties(accountId: string, options: any = {}): Promise < {
        response: http.ClientResponse;body: AccountPropertiesInfoDTO;
    } > {
        const localVarPath = this.basePath + '/account/{accountId}/properties/'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountProperties.');
        }

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: AccountPropertiesInfoDTO;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountPropertiesInfoDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
    /**
     * Returns the configurable properties for a given array of addresses.
     * @summary Get account properties for given array of addresses
     * @param accounstIds 
     * @param {*} [options] Override http request options.
     */
    public getAccountPropertiesFromAccounts(accounstIds: AccountsIds, options: any = {}): Promise < {
        response: http.ClientResponse;body: Array < AccountPropertiesInfoDTO > ;
    } > {
        const localVarPath = this.basePath + '/account/properties';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accounstIds' is not null or undefined
        if (accounstIds === null || accounstIds === undefined) {
            throw new Error('Required parameter accounstIds was null or undefined when calling getAccountPropertiesFromAccounts.');
        }

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(accounstIds, "AccountsIds")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: Array < AccountPropertiesInfoDTO > ;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<AccountPropertiesInfoDTO>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
    /**
     * Returns the account information for an array of accounts.
     * @summary Get accounts information
     * @param accountsIds 
     * @param {*} [options] Override http request options.
     */
    public getAccountsInfo(accountsIds: AccountsIds, options: any = {}): Promise < {
        response: http.ClientResponse;body: Array < AccountInfoDTO > ;
    } > {
        const localVarPath = this.basePath + '/account';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountsIds' is not null or undefined
        if (accountsIds === null || accountsIds === undefined) {
            throw new Error('Required parameter accountsIds was null or undefined when calling getAccountsInfo.');
        }

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(accountsIds, "AccountsIds")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: Array < AccountInfoDTO > ;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<AccountInfoDTO>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
    /**
     * Returns friendly names for accounts.
     * @summary Get readable names for a set of accountIds.
     * @param accountIds 
     * @param {*} [options] Override http request options.
     */
    public getAccountsNames(accountIds: AccountsIds, options: any = {}): Promise < {
        response: http.ClientResponse;body: Array < AccountNamesDTO > ;
    } > {
        const localVarPath = this.basePath + '/account/names';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountIds' is not null or undefined
        if (accountIds === null || accountIds === undefined) {
            throw new Error('Required parameter accountIds was null or undefined when calling getAccountsNames.');
        }

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(accountIds, "AccountsIds")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: Array < AccountNamesDTO > ;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<AccountNamesDTO>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
    /**
     * Gets an array of incoming transactions. A transaction is said to be incoming with respect to an account if the account is the recipient of the transaction. 
     * @summary Get incoming transactions
     * @param publicKey The public key of the account.
     * @param pageSize The number of transactions to return for each request.
     * @param id The transaction id up to which transactions are returned. 
     * @param ordering The ordering criteria: * -id - Descending order by id. * id - Ascending order by id. 
     * @param {*} [options] Override http request options.
     */
    public incomingTransactions(publicKey: string, pageSize ? : number, id ? : string, ordering ? : string, options: any = {}): Promise < {
        response: http.ClientResponse;body: Array < TransactionInfoDTO > ;
    } > {
        const localVarPath = this.basePath + '/account/{publicKey}/transactions/incoming'
            .replace('{' + 'publicKey' + '}', encodeURIComponent(String(publicKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'publicKey' is not null or undefined
        if (publicKey === null || publicKey === undefined) {
            throw new Error('Required parameter publicKey was null or undefined when calling incomingTransactions.');
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "string");
        }

        if (ordering !== undefined) {
            localVarQueryParameters['ordering'] = ObjectSerializer.serialize(ordering, "string");
        }

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: Array < TransactionInfoDTO > ;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TransactionInfoDTO>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
    /**
     * Gets an array of outgoing transactions. A transaction is said to be outgoing with respect to an account if the account is the sender of the transaction.
     * @summary Get outgoing transactions
     * @param publicKey The public key of the account.
     * @param pageSize The number of transactions to return for each request.
     * @param id The transaction id up to which transactions are returned. 
     * @param ordering The ordering criteria: * -id - Descending order by id. * id - Ascending order by id. 
     * @param {*} [options] Override http request options.
     */
    public outgoingTransactions(publicKey: string, pageSize ? : number, id ? : string, ordering ? : string, options: any = {}): Promise < {
        response: http.ClientResponse;body: Array < TransactionInfoDTO > ;
    } > {
        const localVarPath = this.basePath + '/account/{publicKey}/transactions/outgoing'
            .replace('{' + 'publicKey' + '}', encodeURIComponent(String(publicKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'publicKey' is not null or undefined
        if (publicKey === null || publicKey === undefined) {
            throw new Error('Required parameter publicKey was null or undefined when calling outgoingTransactions.');
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "string");
        }

        if (ordering !== undefined) {
            localVarQueryParameters['ordering'] = ObjectSerializer.serialize(ordering, "string");
        }

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: Array < TransactionInfoDTO > ;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TransactionInfoDTO>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
    /**
     * Gets an array of aggregate bonded transactions where the account is the sender or requires to cosign the transaction. 
     * @summary Get aggregate bonded transactions information
     * @param publicKey The public key of the account.
     * @param pageSize The number of transactions to return for each request.
     * @param id The transaction id up to which transactions are returned. 
     * @param ordering The ordering criteria. * -id - Descending order by id. * id - Ascending order by id. 
     * @param {*} [options] Override http request options.
     */
    public partialTransactions(publicKey: string, pageSize ? : number, id ? : string, ordering ? : string, options: any = {}): Promise < {
        response: http.ClientResponse;body: Array < TransactionInfoDTO > ;
    } > {
        const localVarPath = this.basePath + '/account/{publicKey}/transactions/partial'
            .replace('{' + 'publicKey' + '}', encodeURIComponent(String(publicKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'publicKey' is not null or undefined
        if (publicKey === null || publicKey === undefined) {
            throw new Error('Required parameter publicKey was null or undefined when calling partialTransactions.');
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "string");
        }

        if (ordering !== undefined) {
            localVarQueryParameters['ordering'] = ObjectSerializer.serialize(ordering, "string");
        }

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: Array < TransactionInfoDTO > ;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TransactionInfoDTO>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
    /**
     * Gets an array of transactions for which an account is the sender or receiver.
     * @summary Get confirmed transactions
     * @param publicKey The public key of the account.
     * @param pageSize The number of transactions to return for each request.
     * @param id The transaction id up to which transactions are returned. 
     * @param ordering The ordering criteria: * -id - Descending order by id. * id - Ascending order by id. 
     * @param {*} [options] Override http request options.
     */
    public transactions(publicKey: string, pageSize ? : number, id ? : string, ordering ? : string, options: any = {}): Promise < {
        response: http.ClientResponse;body: Array < TransactionInfoDTO > ;
    } > {
        const localVarPath = this.basePath + '/account/{publicKey}/transactions'
            .replace('{' + 'publicKey' + '}', encodeURIComponent(String(publicKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'publicKey' is not null or undefined
        if (publicKey === null || publicKey === undefined) {
            throw new Error('Required parameter publicKey was null or undefined when calling transactions.');
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "string");
        }

        if (ordering !== undefined) {
            localVarQueryParameters['ordering'] = ObjectSerializer.serialize(ordering, "string");
        }

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: Array < TransactionInfoDTO > ;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TransactionInfoDTO>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
    /**
     * Gets the array of transactions not included in a block where an account is the sender or receiver. 
     * @summary Get unconfirmed transactions
     * @param publicKey The public key of the account.
     * @param pageSize The number of transactions to return for each request.
     * @param id The transaction id up to which transactions are returned. 
     * @param ordering The ordering criteria. * -id - Descending order by id. * id - Ascending order by id. 
     * @param {*} [options] Override http request options.
     */
    public unconfirmedTransactions(publicKey: string, pageSize ? : number, id ? : string, ordering ? : string, options: any = {}): Promise < {
        response: http.ClientResponse;body: Array < TransactionInfoDTO > ;
    } > {
        const localVarPath = this.basePath + '/account/{publicKey}/transactions/unconfirmed'
            .replace('{' + 'publicKey' + '}', encodeURIComponent(String(publicKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'publicKey' is not null or undefined
        if (publicKey === null || publicKey === undefined) {
            throw new Error('Required parameter publicKey was null or undefined when calling unconfirmedTransactions.');
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "string");
        }

        if (ordering !== undefined) {
            localVarQueryParameters['ordering'] = ObjectSerializer.serialize(ordering, "string");
        }

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: Array < TransactionInfoDTO > ;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TransactionInfoDTO>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
}
export enum BlockRoutesApiApiKeys {}

export class BlockRoutesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications = {
        'default': < Authentication > new VoidAuth(),
    }

    constructor(basePath ? : string);
    constructor(basePathOrUsername: string, password ? : string, basePath ? : string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: BlockRoutesApiApiKeys, value: string) {
        (this.authentications as any)[BlockRoutesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Gets a block from the chain that has the given height.
     * @summary Get block information
     * @param height The height of the block.
     * @param {*} [options] Override http request options.
     */
    public getBlockByHeight(height: number, options: any = {}): Promise < {
        response: http.ClientResponse;body: BlockInfoDTO;
    } > {
        const localVarPath = this.basePath + '/block/{height}'
            .replace('{' + 'height' + '}', encodeURIComponent(String(height)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'height' is not null or undefined
        if (height === null || height === undefined) {
            throw new Error('Required parameter height was null or undefined when calling getBlockByHeight.');
        }

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: BlockInfoDTO;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BlockInfoDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
    /**
     * Returns the receipts linked to a block.
     * @summary Get receipts from a block
     * @param height The height of the block.
     * @param {*} [options] Override http request options.
     */
    public getBlockReceipts(height: number, options: any = {}): Promise < {
        response: http.ClientResponse;body: StatementsDTO;
    } > {
        const localVarPath = this.basePath + '/block/{height}/receipts'
            .replace('{' + 'height' + '}', encodeURIComponent(String(height)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'height' is not null or undefined
        if (height === null || height === undefined) {
            throw new Error('Required parameter height was null or undefined when calling getBlockReceipts.');
        }

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: StatementsDTO;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "StatementsDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
    /**
     * Returns an array of transactions included in a block for a given block height.
     * @summary Get transactions from a block
     * @param height The height of the block.
     * @param pageSize The number of transactions to return for each request.
     * @param id The transaction id up to which transactions are returned.
     * @param {*} [options] Override http request options.
     */
    public getBlockTransactions(height: number, pageSize ? : number, id ? : string, options: any = {}): Promise < {
        response: http.ClientResponse;body: Array < TransactionInfoDTO > ;
    } > {
        const localVarPath = this.basePath + '/block/{height}/transactions'
            .replace('{' + 'height' + '}', encodeURIComponent(String(height)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'height' is not null or undefined
        if (height === null || height === undefined) {
            throw new Error('Required parameter height was null or undefined when calling getBlockTransactions.');
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "string");
        }

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: Array < TransactionInfoDTO > ;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TransactionInfoDTO>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
    /**
     * Gets up to limit number of blocks after given block height.
     * @summary Get blocks information
     * @param height The height of the block. If height -1 is not a multiple of the limit provided, the inferior closest multiple + 1 is used instead.
     * @param limit The number of blocks to be returned.
     * @param {*} [options] Override http request options.
     */
    public getBlocksByHeightWithLimit(height: number, limit: number, options: any = {}): Promise < {
        response: http.ClientResponse;body: Array < BlockInfoDTO > ;
    } > {
        const localVarPath = this.basePath + '/blocks/{height}/limit/{limit}'
            .replace('{' + 'height' + '}', encodeURIComponent(String(height)))
            .replace('{' + 'limit' + '}', encodeURIComponent(String(limit)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'height' is not null or undefined
        if (height === null || height === undefined) {
            throw new Error('Required parameter height was null or undefined when calling getBlocksByHeightWithLimit.');
        }

        // verify required parameter 'limit' is not null or undefined
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling getBlocksByHeightWithLimit.');
        }

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: Array < BlockInfoDTO > ;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<BlockInfoDTO>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
    /**
     * Returns the merkle path for a receipt statement or resolution linked to a block. The path is the complementary data needed to calculate the merkle root. A client can compare if the calculated root equals the one recorded in the block header, verifying that the receipt was linked with the block. 
     * @summary Get the merkle path for a given a receipt statement hash and block
     * @param height The height of the block.
     * @param hash The hash of the receipt statement or resolution.
     * @param {*} [options] Override http request options.
     */
    public getMerkleReceipts(height: number, hash: string, options: any = {}): Promise < {
        response: http.ClientResponse;body: MerkleProofInfoDTO;
    } > {
        const localVarPath = this.basePath + '/block/{height}/receipt/{hash}/merkle'
            .replace('{' + 'height' + '}', encodeURIComponent(String(height)))
            .replace('{' + 'hash' + '}', encodeURIComponent(String(hash)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'height' is not null or undefined
        if (height === null || height === undefined) {
            throw new Error('Required parameter height was null or undefined when calling getMerkleReceipts.');
        }

        // verify required parameter 'hash' is not null or undefined
        if (hash === null || hash === undefined) {
            throw new Error('Required parameter hash was null or undefined when calling getMerkleReceipts.');
        }

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: MerkleProofInfoDTO;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MerkleProofInfoDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
    /**
     * Returns the merkle path for a transaction included in a block. The path is the complementary data needed to calculate the merkle root. A client can compare if the calculated root equals the one recorded in the block header, verifying that the transaction was included in the block. 
     * @summary Get the merkle path for a given a transaction and block
     * @param height The height of the block.
     * @param hash The hash of the transaction.
     * @param {*} [options] Override http request options.
     */
    public getMerkleTransaction(height: number, hash: string, options: any = {}): Promise < {
        response: http.ClientResponse;body: MerkleProofInfoDTO;
    } > {
        const localVarPath = this.basePath + '/block/{height}/transaction/{hash}/merkle'
            .replace('{' + 'height' + '}', encodeURIComponent(String(height)))
            .replace('{' + 'hash' + '}', encodeURIComponent(String(hash)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'height' is not null or undefined
        if (height === null || height === undefined) {
            throw new Error('Required parameter height was null or undefined when calling getMerkleTransaction.');
        }

        // verify required parameter 'hash' is not null or undefined
        if (hash === null || hash === undefined) {
            throw new Error('Required parameter hash was null or undefined when calling getMerkleTransaction.');
        }

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: MerkleProofInfoDTO;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MerkleProofInfoDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
}
export enum ChainRoutesApiApiKeys {}

export class ChainRoutesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications = {
        'default': < Authentication > new VoidAuth(),
    }

    constructor(basePath ? : string);
    constructor(basePathOrUsername: string, password ? : string, basePath ? : string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: ChainRoutesApiApiKeys, value: string) {
        (this.authentications as any)[ChainRoutesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Returns the current height of the blockchain.
     * @summary Get the current height of the chain
     * @param {*} [options] Override http request options.
     */
    public getBlockchainHeight(options: any = {}): Promise < {
        response: http.ClientResponse;body: HeightInfoDTO;
    } > {
        const localVarPath = this.basePath + '/chain/height';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: HeightInfoDTO;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "HeightInfoDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
    /**
     * Gets the current score of the blockchain. The higher the score, the better the chain. During synchronization, nodes try to get the best blockchain in the network.  The score for a block is derived from its difficulty and the time (in seconds) that has elapsed since the last block:      block score = difficulty  time elasped since last block 
     * @summary Get the current score of the chain
     * @param {*} [options] Override http request options.
     */
    public getBlockchainScore(options: any = {}): Promise < {
        response: http.ClientResponse;body: BlockchainScoreDTO;
    } > {
        const localVarPath = this.basePath + '/chain/score';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: BlockchainScoreDTO;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BlockchainScoreDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
}
export enum DiagnosticRoutesApiApiKeys {}

export class DiagnosticRoutesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications = {
        'default': < Authentication > new VoidAuth(),
    }

    constructor(basePath ? : string);
    constructor(basePathOrUsername: string, password ? : string, basePath ? : string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: DiagnosticRoutesApiApiKeys, value: string) {
        (this.authentications as any)[DiagnosticRoutesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Returns diagnostic information about the node storage.
     * @summary Get the storage information of the node
     * @param {*} [options] Override http request options.
     */
    public getDiagnosticStorage(options: any = {}): Promise < {
        response: http.ClientResponse;body: StorageInfoDTO;
    } > {
        const localVarPath = this.basePath + '/diagnostic/storage';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: StorageInfoDTO;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "StorageInfoDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
    /**
     * Returns the version of the running rest component.
     * @summary Get the version of the running rest component
     * @param {*} [options] Override http request options.
     */
    public getServerInfo(options: any = {}): Promise < {
        response: http.ClientResponse;body: ServerDTO;
    } > {
        const localVarPath = this.basePath + '/diagnostic/server';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: ServerDTO;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ServerDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
}
export enum MosaicRoutesApiApiKeys {}

export class MosaicRoutesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications = {
        'default': < Authentication > new VoidAuth(),
    }

    constructor(basePath ? : string);
    constructor(basePathOrUsername: string, password ? : string, basePath ? : string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: MosaicRoutesApiApiKeys, value: string) {
        (this.authentications as any)[MosaicRoutesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Gets the mosaic definition for a given mosaicId.
     * @summary Get mosaic information
     * @param mosaicId The mosaic identifier.
     * @param {*} [options] Override http request options.
     */
    public getMosaic(mosaicId: string, options: any = {}): Promise < {
        response: http.ClientResponse;body: MosaicInfoDTO;
    } > {
        const localVarPath = this.basePath + '/mosaic/{mosaicId}'
            .replace('{' + 'mosaicId' + '}', encodeURIComponent(String(mosaicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mosaicId' is not null or undefined
        if (mosaicId === null || mosaicId === undefined) {
            throw new Error('Required parameter mosaicId was null or undefined when calling getMosaic.');
        }

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: MosaicInfoDTO;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MosaicInfoDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
    /**
     * Gets an array of mosaic definition.
     * @summary Get mosaics information for an array of mosaics
     * @param mosaicIds 
     * @param {*} [options] Override http request options.
     */
    public getMosaics(mosaicIds: MosaicIds, options: any = {}): Promise < {
        response: http.ClientResponse;body: Array < MosaicInfoDTO > ;
    } > {
        const localVarPath = this.basePath + '/mosaic';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mosaicIds' is not null or undefined
        if (mosaicIds === null || mosaicIds === undefined) {
            throw new Error('Required parameter mosaicIds was null or undefined when calling getMosaics.');
        }

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(mosaicIds, "MosaicIds")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: Array < MosaicInfoDTO > ;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<MosaicInfoDTO>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
    /**
     * Returns friendly names for mosaics.
     * @summary Get readable names for a set of mosaics
     * @param mosaicIds 
     * @param {*} [options] Override http request options.
     */
    public getMosaicsNames(mosaicIds: MosaicIds, options: any = {}): Promise < {
        response: http.ClientResponse;body: Array < MosaicNamesDTO > ;
    } > {
        const localVarPath = this.basePath + '/mosaic/names';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mosaicIds' is not null or undefined
        if (mosaicIds === null || mosaicIds === undefined) {
            throw new Error('Required parameter mosaicIds was null or undefined when calling getMosaicsNames.');
        }

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(mosaicIds, "MosaicIds")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: Array < MosaicNamesDTO > ;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<MosaicNamesDTO>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
}
export enum NamespaceRoutesApiApiKeys {}

export class NamespaceRoutesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications = {
        'default': < Authentication > new VoidAuth(),
    }

    constructor(basePath ? : string);
    constructor(basePathOrUsername: string, password ? : string, basePath ? : string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: NamespaceRoutesApiApiKeys, value: string) {
        (this.authentications as any)[NamespaceRoutesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Gets the namespace for a given namespaceId.
     * @summary Get namespace information
     * @param namespaceId The namespace identifier.
     * @param {*} [options] Override http request options.
     */
    public getNamespace(namespaceId: string, options: any = {}): Promise < {
        response: http.ClientResponse;body: NamespaceInfoDTO;
    } > {
        const localVarPath = this.basePath + '/namespace/{namespaceId}'
            .replace('{' + 'namespaceId' + '}', encodeURIComponent(String(namespaceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'namespaceId' is not null or undefined
        if (namespaceId === null || namespaceId === undefined) {
            throw new Error('Required parameter namespaceId was null or undefined when calling getNamespace.');
        }

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: NamespaceInfoDTO;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NamespaceInfoDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
    /**
     * Gets an array of namespaces for a given account address.
     * @summary Get namespaces owned by an account
     * @param accountId The address or public key of the account.
     * @param pageSize The number of namespaces to return.
     * @param id The namespace id up to which namespace objects are returned.
     * @param {*} [options] Override http request options.
     */
    public getNamespacesFromAccount(accountId: string, pageSize ? : number, id ? : string, options: any = {}): Promise < {
        response: http.ClientResponse;body: Array < NamespaceInfoDTO > ;
    } > {
        const localVarPath = this.basePath + '/account/{accountId}/namespaces'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getNamespacesFromAccount.');
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "string");
        }

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: Array < NamespaceInfoDTO > ;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<NamespaceInfoDTO>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
    /**
     * Gets namespaces for a given array of addresses.
     * @summary Get namespaces for given array of addresses
     * @param accountsIds 
     * @param pageSize The number of namespaces to return.
     * @param id The namespace id up to which namespace objects are returned.
     * @param {*} [options] Override http request options.
     */
    public getNamespacesFromAccounts(accountsIds: AccountsIds, pageSize ? : number, id ? : string, options: any = {}): Promise < {
        response: http.ClientResponse;body: Array < NamespaceInfoDTO > ;
    } > {
        const localVarPath = this.basePath + '/account/namespaces';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountsIds' is not null or undefined
        if (accountsIds === null || accountsIds === undefined) {
            throw new Error('Required parameter accountsIds was null or undefined when calling getNamespacesFromAccounts.');
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "string");
        }

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(accountsIds, "AccountsIds")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: Array < NamespaceInfoDTO > ;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<NamespaceInfoDTO>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
    /**
     * Returns friendly names for namespaces.
     * @summary Get readable names for a set of namespaces
     * @param accountsIds 
     * @param {*} [options] Override http request options.
     */
    public getNamespacesNames(accountsIds: NamespaceIds, options: any = {}): Promise < {
        response: http.ClientResponse;body: Array < NamespaceNameDTO > ;
    } > {
        const localVarPath = this.basePath + '/namespace/names';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountsIds' is not null or undefined
        if (accountsIds === null || accountsIds === undefined) {
            throw new Error('Required parameter accountsIds was null or undefined when calling getNamespacesNames.');
        }

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(accountsIds, "NamespaceIds")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: Array < NamespaceNameDTO > ;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<NamespaceNameDTO>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
}
export enum NetworkRoutesApiApiKeys {}

export class NetworkRoutesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications = {
        'default': < Authentication > new VoidAuth(),
    }

    constructor(basePath ? : string);
    constructor(basePathOrUsername: string, password ? : string, basePath ? : string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: NetworkRoutesApiApiKeys, value: string) {
        (this.authentications as any)[NetworkRoutesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Returns the current network type.
     * @summary Get the current network type of the chain
     * @param {*} [options] Override http request options.
     */
    public getNetworkType(options: any = {}): Promise < {
        response: http.ClientResponse;body: NetworkTypeDTO;
    } > {
        const localVarPath = this.basePath + '/network';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: NetworkTypeDTO;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NetworkTypeDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
}
export enum NodeRoutesApiApiKeys {}

export class NodeRoutesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications = {
        'default': < Authentication > new VoidAuth(),
    }

    constructor(basePath ? : string);
    constructor(basePathOrUsername: string, password ? : string, basePath ? : string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: NodeRoutesApiApiKeys, value: string) {
        (this.authentications as any)[NodeRoutesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Supplies additional information about the application running on a node. 
     * @summary Get the node information
     * @param {*} [options] Override http request options.
     */
    public getNodeInfo(options: any = {}): Promise < {
        response: http.ClientResponse;body: NodeInfoDTO;
    } > {
        const localVarPath = this.basePath + '/node/info';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: NodeInfoDTO;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NodeInfoDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
    /**
     * Gets the node time at the moment the reply was sent and received.
     * @summary Get the node time
     * @param {*} [options] Override http request options.
     */
    public getNodeTime(options: any = {}): Promise < {
        response: http.ClientResponse;body: NodeTimeDTO;
    } > {
        const localVarPath = this.basePath + '/node/time';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: NodeTimeDTO;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NodeTimeDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
}
export enum TransactionRoutesApiApiKeys {}

export class TransactionRoutesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications = {
        'default': < Authentication > new VoidAuth(),
    }

    constructor(basePath ? : string);
    constructor(basePathOrUsername: string, password ? : string, basePath ? : string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: TransactionRoutesApiApiKeys, value: string) {
        (this.authentications as any)[TransactionRoutesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Announces a cosignature transaction to the network.
     * @summary Announce a cosignature transaction
     * @param cosignature 
     * @param {*} [options] Override http request options.
     */
    public announceCosignatureTransaction(cosignature: Cosignature, options: any = {}): Promise < {
        response: http.ClientResponse;body: AnnounceTransactionInfoDTO;
    } > {
        const localVarPath = this.basePath + '/transaction/cosignature';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'cosignature' is not null or undefined
        if (cosignature === null || cosignature === undefined) {
            throw new Error('Required parameter cosignature was null or undefined when calling announceCosignatureTransaction.');
        }

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(cosignature, "Cosignature")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: AnnounceTransactionInfoDTO;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AnnounceTransactionInfoDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
    /**
     * Announces an aggregate bonded transaction to the network.
     * @summary Announce an aggregate bonded transaction
     * @param transactionPayload 
     * @param {*} [options] Override http request options.
     */
    public announcePartialTransaction(transactionPayload: TransactionPayload, options: any = {}): Promise < {
        response: http.ClientResponse;body: AnnounceTransactionInfoDTO;
    } > {
        const localVarPath = this.basePath + '/transaction/partial';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transactionPayload' is not null or undefined
        if (transactionPayload === null || transactionPayload === undefined) {
            throw new Error('Required parameter transactionPayload was null or undefined when calling announcePartialTransaction.');
        }

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(transactionPayload, "TransactionPayload")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: AnnounceTransactionInfoDTO;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AnnounceTransactionInfoDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
    /**
     * Announces a transaction to the network. It is recommended to use the NEM2-SDK to announce transactions as they should be serialized. 
     * @summary Announce a new transaction
     * @param transactionPayload 
     * @param {*} [options] Override http request options.
     */
    public announceTransaction(transactionPayload: TransactionPayload, options: any = {}): Promise < {
        response: http.ClientResponse;body: AnnounceTransactionInfoDTO;
    } > {
        const localVarPath = this.basePath + '/transaction';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transactionPayload' is not null or undefined
        if (transactionPayload === null || transactionPayload === undefined) {
            throw new Error('Required parameter transactionPayload was null or undefined when calling announceTransaction.');
        }

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(transactionPayload, "TransactionPayload")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: AnnounceTransactionInfoDTO;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AnnounceTransactionInfoDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
    /**
     * Returns transaction information given a transactionId or hash.
     * @summary Get transaction information
     * @param transactionId The transaction id or hash.
     * @param {*} [options] Override http request options.
     */
    public getTransaction(transactionId: string, options: any = {}): Promise < {
        response: http.ClientResponse;body: TransactionInfoDTO;
    } > {
        const localVarPath = this.basePath + '/transaction/{transactionId}'
            .replace('{' + 'transactionId' + '}', encodeURIComponent(String(transactionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transactionId' is not null or undefined
        if (transactionId === null || transactionId === undefined) {
            throw new Error('Required parameter transactionId was null or undefined when calling getTransaction.');
        }

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: TransactionInfoDTO;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionInfoDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
    /**
     * Returns the transaction status for a given hash.
     * @summary Get transaction status
     * @param hash The transaction hash.
     * @param {*} [options] Override http request options.
     */
    public getTransactionStatus(hash: string, options: any = {}): Promise < {
        response: http.ClientResponse;body: TransactionStatusDTO;
    } > {
        const localVarPath = this.basePath + '/transaction/{hash}/status'
            .replace('{' + 'hash' + '}', encodeURIComponent(String(hash)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'hash' is not null or undefined
        if (hash === null || hash === undefined) {
            throw new Error('Required parameter hash was null or undefined when calling getTransactionStatus.');
        }

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: TransactionStatusDTO;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionStatusDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
    /**
     * Returns transactions information for a given array of transactionIds.
     * @summary Get transactions information
     * @param transactionIds 
     * @param {*} [options] Override http request options.
     */
    public getTransactions(transactionIds: TransactionIds, options: any = {}): Promise < {
        response: http.ClientResponse;body: Array < TransactionInfoDTO > ;
    } > {
        const localVarPath = this.basePath + '/transaction';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transactionIds' is not null or undefined
        if (transactionIds === null || transactionIds === undefined) {
            throw new Error('Required parameter transactionIds was null or undefined when calling getTransactions.');
        }

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(transactionIds, "TransactionIds")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: Array < TransactionInfoDTO > ;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TransactionInfoDTO>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
    /**
     * Returns an array of transaction statuses for a given array of transaction hashes.
     * @summary Get transactions status.
     * @param transactionHashes 
     * @param {*} [options] Override http request options.
     */
    public getTransactionsStatuses(transactionHashes: TransactionHashes, options: any = {}): Promise < {
        response: http.ClientResponse;body: Array < TransactionStatusDTO > ;
    } > {
        const localVarPath = this.basePath + '/transaction/statuses';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = ( < any > Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transactionHashes' is not null or undefined
        if (transactionHashes === null || transactionHashes === undefined) {
            throw new Error('Required parameter transactionHashes was null or undefined when calling getTransactionsStatuses.');
        }

        ( < any > Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(transactionHashes, "TransactionHashes")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                ( < any > localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise < {
            response: http.ClientResponse;body: Array < TransactionStatusDTO > ;
        } > ((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TransactionStatusDTO>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(body);
                    } else {
                        reject({
                            statusCode: response.statusCode,
                            statusMessage: response.statusMessage
                        });
                    }
                }
            });
        });
    }
}
